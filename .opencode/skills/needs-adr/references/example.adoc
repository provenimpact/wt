= ADR Examples

This file shows a complete example of an ADR index and two ADR files for an e-commerce project.

== Index File (docs/adrs/index.adoc)

....
= Architecture Decision Records
:version: 1.0.0
:last-updated: 2026-02-19
:toc:

[cols="1,3,1,1", options="header"]
|===
| ADR | Decision | Status | Date

| <<0001-use-typescript.adoc#,ADR-0001>>
| Use TypeScript for backend and frontend
| Accepted
| 2026-02-18

| <<0002-use-postgresql.adoc#,ADR-0002>>
| Use PostgreSQL for persistence
| Accepted
| 2026-02-19
|===
....

== ADR-0001 (docs/adrs/0001-use-typescript.adoc)

....
= ADR-0001: Use TypeScript for Backend and Frontend
:status: Accepted
:date: 2026-02-18
:deciders: Engineering team

== Context

The project requires a language for both backend (API server) and frontend (web application). Using the same language across the stack reduces context switching and enables code sharing (validation logic, types, utilities).

== Decision

Use TypeScript for both backend and frontend development. The backend will run on Node.js with a TypeScript-first framework. The frontend will use a TypeScript-first UI framework.

== Consequences

Easier:
- Shared type definitions between frontend and backend
- Single language expertise required for the team
- Large ecosystem of TypeScript-compatible libraries

Harder:
- CPU-intensive operations are slower than compiled languages
- Runtime type checking requires additional tooling (e.g., Zod, io-ts)

== Alternatives Considered

=== Go backend + TypeScript frontend
Strong performance and type safety on the backend, but requires maintaining two languages and duplicating type definitions across the stack.

=== Python backend + TypeScript frontend
Rapid backend prototyping with Python, but loses type sharing and requires separate teams or skill sets.
....

== ADR-0002 (docs/adrs/0002-use-postgresql.adoc)

....
= ADR-0002: Use PostgreSQL for Persistence
:status: Accepted
:date: 2026-02-19
:deciders: Engineering team

== Context

The e-commerce system requires persistent storage for users, products, orders, and inventory. The data is relational in nature with strong consistency requirements (e.g., order totals must match line items, inventory must be accurately tracked).

== Decision

Use PostgreSQL as the primary database for all persistent data.

== Consequences

Easier:
- Strong ACID compliance for financial transactions
- Rich querying capabilities (full-text search, JSON support, window functions)
- Mature ecosystem with well-documented migration tooling

Harder:
- Horizontal scaling requires additional infrastructure (read replicas, partitioning)
- Schema migrations need careful planning in production

== Alternatives Considered

=== MongoDB
Flexible schema would speed up early development, but the relational nature of e-commerce data (orders referencing products, users referencing addresses) makes document storage awkward and risks data inconsistency.

=== SQLite
Simple to deploy and operate, but lacks concurrent write support needed for a multi-user e-commerce system.
....
